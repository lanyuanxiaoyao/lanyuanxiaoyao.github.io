---
layout: post
title: 原码、反码和补码
date: 2017-03-26 17:08
categories: Others
tags: [计算机组成原理]
---

* content
{:toc}

# 概述
相信每一个学计算机的同学都头疼过原码,补码和反码这三个东西,甚至有时候还会冒出一个移码  
我们人类在计数的时候,用的都是十进制,但是计算机可不认这个,它们的世界用的是二进制来表示数,这个时候我们如果想要了解它们的世界是怎么样的,那么首先就要认识它们是怎么数数的  
  
***我们把我们正常计数用的表示方法表示的数称为“真值”，把机器里面表达的数称为“机器数”***

# 原码
## 概念
**原码(true form)** 是一种计算机中对数字的二进制定点表示方法.原码表示法在数值前面增加了一位符号位（即最高位为符号位）:正数该位为0,负数该位为1(**0有两种表示：+0和-0**),其余位表示数值的大小.  
数学表示如下(有的书上会约定符号位和数值位之间用逗号隔开，所以表达式会有所不同，这里的以没有逗号隔开的为准)  
若$X$是纯整数:  
$$
[X]_原=
\begin{cases}
X & 0\le X\lt 2^{n-1}\\
2^{n-1}-X & -2^{n-1}\lt X\le 0
\end{cases}
$$  

若$X$是纯小数:
$$
[X]_原=
\begin{cases}
X & 0\le X\lt 1\\
1-X & -1\lt X\le 0
\end{cases}
$$

数学公式看着就一脸懵逼,但是实际上并没有那么难理解,实际上就是说,如果我们的计算机里面用8个二进制位来表示一个数,那么最高位就作为符号位,剩下的7位二进制位表示数(空出来的位置补0),例如
$$
整数\\
[+3]_原=00000011\\
[-3]_原=2^8-(-00000011)=10000011\\
小数\\
[+13]_原=0.0001101\\
[-13]_原=1-(-0.0001101)=1.0001101
$$

既然已知真值可以求原码，那么已知原码也可以反过来求得真值，这里就不再赘述  

特别的，当$X=0$的时候

$$
[+0]_原=00000000\\
[-0]_原=10000000(2^8)-(00000000)=10000000
$$

可以看到$[+0]_原$并不等于$[-0]_原$，所以原码里面的“零”有两种表示方式

## 表示范围
因为我们用了最高位来表示符号位,所以如果我们的计算机用$n$位来表示一个数的话,那么我们实际用来表示数字大小的只有$n-1$位,所以**有符号位原码**可以表示数的范围为

$$
-2^{n-1}-1\sim+2^{n-1}-1
$$

事实上有时候我们不需要用到符号,所以我们也会有无符号数的存在,相应的也会有无符号原码,所以如果计算机用$n$位来表示一个数的话,那么全部数位都用来表示数的大小,所以**无符号位原码**可以表示数的范围为  

$$
0\sim2^n-1
$$

## 优点
简单直观,例如,我们用8位二进制表示一个数,`+11`的原码为`00001011`,`-11`的原码就是`10001011`,非常接近我们平常的计数习惯,正数就在前面写个`+`,负数就在前面写个`-`

## 缺点
- 原码不能直接参加运算,可能会出错.例如数学上,`1+(-1)=0`,而在二进制中
`00000001+10000001=10000010`,换算成十进制为`-2`.显然出错了.  
所以原码的符号位不能直接参与运算,必须和其他位分开,这就增加了硬件的开销和复杂性
- 使用原码进行加减法运算的时候，如果是两个符号不同的数运算，还要判断绝对值大小，用大的减去小的，然后再判断符号，运算步骤麻烦又费事，本来是加法却又要用到减法来计算

# 补码
## 概念
由于原码作计算的时候的种种不便，所以引入了补码的概念  
在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。  
数学表示如下  
若$X$是纯整数:

$$
[X]_补=
\begin{cases}
X & 0\le X\le 2^{n-1}-1\\
2^n+X & -2^{n-1}\le X\le 0
\end{cases}
$$

若$X$是纯小数:

$$
[X]_补=
\begin{cases}
X & 0\le X \lt 1\\
2+X & -1\le X\lt 0
\end{cases}
$$

因为补码比较重要,因此需要详细说明,首先是补码的原理,补码最大的作用是把减法变成了加法,让计算机可以只用一种电路就可以同时计算加法和减法,要讲解补码的原理,首先就要引入**模**的概念  
>“模”是指一个计量系统的计数范围。如时钟等。计算机也可以看成一个计量机器，它也有一个计量范围，即都存在一个“模”。  
>例如：时钟的计量范围是`0～11`，模为`12`。表示n位的计算机计量范围是`!$0\sim 2^n-1$`，模为`!$2^n$`。  
“模”实质上是计量器产生“溢出”的量，它的值在计量器上表示不出来，计量器上只能表示出模的余数。任何有模的计量器，均可化减法为加法运算。  
例如：假设当前时针指向`10`点，而准确时间是`6`点，调整时间可有以下两种拨法：一种是倒拨`4`小时，即：`10-4=6`；另一种是顺拨`8`小时：`10+8=12+6=6`
在以`12`模的系统中，加`8`和减`4`效果是一样的，因此凡是减`4`运算，都可以用加`8`来代替。对“模”而言，`8`和`4`互为补数。实际上以`12`模的系统中，`11`和`1`，`10`和`2`，`9`和`3`，`7`和`5`，`6`和`6`都有这个特性。共同的特点是两者相加等于模。  
对于计算机，其概念和方法完全一样。`!$n$`位计算机，设`!$n=8$`， 所能表示的最大数是`11111111`，若再加`1`成为`100000000`(9位），但因只有`8`位，最高位`1`自然丢失。又回了`00000000`，所以`8`位二进制系统的模为`!$2^8$`。在这样的系统中减法问题也可以化成加法问题，只需把减数用相应的补数表示就可以了。把补数用到计算机对数的处理上，就是补码。

然后自然就是数如何表示,用通俗的说法就是
- **正数**的补码和其原码相同
- **负数**的补码,将其对应正数二进制表示所有位取反(包括符号位),然后+1

举个例子,还是8位表示一个数

$$
正数\\
[3]_原=00000011\\
[3]_补=00000011\\
负数\\
[-3]_原=10000011\\
[-3]_补=11111101\\
[3]_原00000011→(各位取反)11111100→[-3]_补11111101
$$

当`!$X=0$`的时候

$$
[+0]_补=[-0]_补=00000000
$$

所以补码中的“零”只用一种表示方式

## 表示范围

# 反码
## 概念
反码是数值存储的一种，但是由于补码更能有效表现数字在计算机中的形式，所以多数计算机一般都不采用反码表示数。  
反码表示法规定
- **正数**的反码与其原码相同
- **负数**的反码是对其原码逐位取反，但**符号位除外**

数学表示如下  
若$X$是纯整数:  

$$
[X]_反=
\begin{cases}
X & 0\le X\le 2^{n-1}-1\\
2^n-1+X & -(2^{n-1}-1)\le X\le 0
\end{cases}
$$

若$X$是纯小数:

$$
[X]_反=
\begin{cases}
X & 0\le X \lt 1\\
2-2^{-(n-1)}+X & -1\lt X\le 0
\end{cases}
$$

数学公式就是不如一个例子来得只管,所以举个例子,还是用8个二进制位表示一个数

$$
正数\\
[3]_原=00000011\\
[3]_反=00000011\\
负数\\
[-3]_原=10000011\\
[-3]_反=11111100
$$

当`!$X=0$`的时候

$$
[+0]_反=00000000\\
[-0]_反=10000000(2^8)-1+00000000=01111111
$$

$[+0]_反$并不等于$[-0]_反$，所以反码的“零”也有两种表示方式

## 表示范围

# 移码

# 总结
- 三种机器数的**最高位均是符号位**
- 当真值为**正数**的时候，原码、补码、反码的表示均**相同**；
- 当真值为**负数**的时候，三种机器数的表示方式都不同，但是符号位都是`1`，数值部分，补码是原码的“**求反+1**”，反码是原码的“**除符号位，每位取反**”
